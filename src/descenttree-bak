void Pedigree::determineOriginalFounders() const{
	
	std::set<Individual*,compareIndividual>::iterator individualIt = _individuals.begin();
	//while(individualIt != _individuals.end()){
	//	if((*individualIt)->isOrdinaryFounder() == true){
	//		std::cout << "Ordinary founder :" << (*individualIt)->getId() << std::endl;
	//		(*individualIt)->checkIfOriginalFounder();
	//	}
	//	++individualIt;
	//}
	
	// Test:
	std::vector<Individual*> oF;
	individualIt = _individuals.begin();
	while(individualIt  != _individuals.end()){
		if((*individualIt)->isOrdinaryFounder() == true){
			oF.push_back((*individualIt));
		}
		++individualIt;
	}
	std::cout << "OF size " << oF.size() << std::endl;
	// Determine the number of Descent Trees and founding groups:
	std::vector<std::string> ordinaryFounders;
	// Push all the ordinary founders in a vector
	individualIt = _individuals.begin();
	while(individualIt != _individuals.end()){
		if((*individualIt)->isOrdinaryFounder() == true){ 
			std::cout << "ORD " << (*individualIt)->getId() << std::endl;
			ordinaryFounders.push_back((*individualIt)->getId().get());
		}
		++individualIt;
	}
	while(ordinaryFounders.size() != 0){
	std::string temp = ordinaryFounders[0];
	
	std::set<std::string> descentTree;
	descentTree.insert(temp);
	_determineDescentTree(descentTree,temp);
	bool originalFounderGroup = true;
	std::set<std::string>::iterator it = descentTree.begin();
	while(it != descentTree.end()){
		individualIt = _individuals.find(new Individual(*it));
		if(individualIt != _individuals.end() && (*individualIt)->isOrdinaryFounder()==true){
			++it; continue;
		}
		originalFounderGroup = false;
		break;
	}
	if(originalFounderGroup){
		// Set the originalFounder flag
		it = descentTree.begin();
		while(it != descentTree.end()){
			individualIt = _individuals.find(new Individual(*it));
			if(individualIt != _individuals.end()){
				(*individualIt)->setOrdinaryFounder(false);
				(*individualIt)->setOriginalFounder(true);
			}
			++it;
		}
	}
	std::vector<std::string>::iterator vit;
	it = descentTree.begin();
	while(it != descentTree.end()){
		// Delete these individuals from the ordinaryFounders vector
		vit = find(ordinaryFounders.begin(),ordinaryFounders.end(),*it);
		if (vit != ordinaryFounders.end()) ordinaryFounders.erase(vit);
		++it;
	}
	}//end of while
	// Print the original and ordinary founders:
	individualIt = _individuals.begin();
	while(individualIt != _individuals.end()){
		if((*individualIt)->isOrdinaryFounder() == true){ 
			std::cout << "ORD " << (*individualIt)->getId() << std::endl;
		}
		if((*individualIt)->isOriginalFounder() == true){ 
			std::cout << "ORG*** " << (*individualIt)->getId() << std::endl;
		}
		++individualIt;
	}
}

void Pedigree::_determineDescentTree(std::set<std::string>& descentTree, std::string individual) const{
	
	std::set<Individual*,compareIndividual>::iterator it = _individuals.find(new Individual(individual));
	if(it != _individuals.end()){
		std::vector<std::string> spouses = (*it)->getSpouseIds();
		unsigned i=0;
		while(i < spouses.size()){
			std::pair<std::set<std::string>::iterator,bool> pit = descentTree.insert(spouses[i]);
			if(pit.second) _determineDescentTree(descentTree,spouses[i]);
			i++;
		}
	}
	
}






